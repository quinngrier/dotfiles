#
# This file (~/.bashrc-bottom) holds the code that should be put at the
# bottom of the ~/.bashrc file. The following command can be put at the
# bottom of the ~/.bashrc file to do this indirectly:
#
#       . ~/.bashrc-bottom
#
# The reason for not putting the code directly into the ~/.bashrc file
# is to make it easier to work with default ~/.bashrc files on systems
# that provide them. It is easier to make this file portable and make
# the above small change on each system than it is to make a portable
# ~/.bashrc file that reasonably subsumes all default ~/.bashrc files.
#
# Note that the master copy of the default ~/.bashrc file can sometimes
# be found at one of the following locations:
#
#       /etc/defaults/etc/skel/.bashrc
#       /etc/skel/.bashrc
#

#-----------------------------------------------------------------------

#
# This alias goes along with the ~/bin/s script. The problem is that we
# want the script to show the output of the jobs command, but if we run
# the jobs command in the script, it will show the jobs of the script's
# shell instance, not the jobs of our interactive shell instance. The
# solution is to use this alias to run the jobs command and pass the
# output to the script as an argument. We also pass an extra "token"
# argument so that the script can detect if it was accidentally run
# without the alias.
#

alias s='s_alias_jobs=$(jobs -l) && s s_alias_jobs "$s_alias_jobs"'

#-----------------------------------------------------------------------

HISTFILESIZE=100000
HISTSIZE=$HISTFILESIZE
shopt -s cmdhist histappend lithist

#
# Set the prompt string and window title.
#
# The prompt string looks like this:
#
#       [0][user@host:/current/working/directory]
#       $
#
# The "[0]" part is the exit status of the last command. If the command
# was a pipeline, then the exit status of every command in the pipeline
# will appear, separated by spaces. For example, "true | false | false"
# yields "[0 1 1]". The first line of the prompt string is colored all
# the way to the edge of the window for visual distinction.
#
# The window title looks like this:
#
#       user@host:/current/working/directory
#
# Note the use of \e[K to clear from the cursor to the end of the line
# instead of \e[2K to clear the entire line. Clearing the entire line
# would damage the last line of output of any program that doesn't
# output a final newline character.
#

PS1='\[\e[0m\]\[\e]0;\u@\H:\w\a\]\[\e[37;44m\]\[\e[K\]'
PS1=$PS1'[${PIPESTATUS[@]}][\u@\H:\w]\[\e[0m\]\n\$ '

#
# Set up gpg-agent and ssh-agent.
#
# The idea here is to create a string $boot that represents the system
# boot time and store the agent hookup commands in some files in $HOME
# whose names include $boot. We can then check whether the files exist
# to decide whether the agents are already running. If the files exist,
# we'll eval them to hook ourselves to the already running agents, and
# if not, we'll start the agents and create the files first.
#

eval " $(
  case $(uname) in
    (*CYGWIN*)
      boot=$(WMIC OS GET LastBootUpTime | tr -d '\r ' | sed -n 2p)
    ;;
    (*)
      boot=$(who -b | sed 's/.*boot//')
      boot=$(date -d "$boot" +%s)
    ;;
  esac
  start_or_inherit() {
    local x="$HOME/.bashrc-$1"
    if [[ ! -f "$x-$boot" ]]; then
      rm -f "$x-"*
      eval "$@" >"$x-$boot.$$" && mv "$x-$boot.$$" "$x-$boot"
    fi
    x=$(cat "$x-$boot") && printf '%s\n' "$x"
  }
  start_or_inherit gpg-agent --daemon
  start_or_inherit ssh-agent
)"

GPG_TTY=$(tty)
export GPG_TTY

#
# Free up Ctrl-s and Ctrl-q by disabling XON/XOFF flow control.
#

stty -ixon

#
# The authors of this file have waived all copyright and
# related or neighboring rights to the extent permitted by
# law as described by the CC0 1.0 Universal Public Domain
# Dedication. You should have received a copy of the full
# dedication along with this file, typically as a file
# named <CC0-1.0.txt>. If not, it may be available at
# <https://creativecommons.org/publicdomain/zero/1.0/>.
#
